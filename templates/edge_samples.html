<head>
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css"
integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

<script src="https://code.jquery.com/jquery-3.1.1.slim.min.js"
integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>

<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"
integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="{{ url_for('static', filename='js/d3.v3.min.js') }}"></script>
<style>
.pw1 {
   color: pink;
}

.pw2 {
   color: green;
}
</style>
</head>
<body>
    <div id="overview" class="container">
        <div class="row">
            <h2><span class="pw1">{{pw1}}</span> <span class="pw2">{{pw2}}</span></h2>
        <h5><a href="{{ url_for('pathcore_network') }}">Return to network</a></h5>
        <p>        
            A summary expression score per sample was determined based on
            the normalized expression values of the genes in the 2 pathway annotations,
            where each expression value was weighted by its gene's odds ratio.
            Displayed are the <a href="#most-expressed-samples">10 most expressed</a>
            and <a href="#least-expressed-samples">10 least expressed</a> samples. 
        </p>
        <p>
            If a gene-by-sample square has an experiment associated with it (on hover), you can click on
            that square to view the gene expression values for all samples from that experiment.
        </p>
        </div>
    </div>
    <div class="container" id="most-expressed-samples">
    <h4>10 most expressed samples</h4>
    <div class="row">
        <div class="col-xs-6">
        <div class="text-right">
            <button type="button" class="btn btn-default toggle-genes">Sort genes alphabetically</button>
        </div>
        </div>
    </div>
    <div class="row" id="most_expressed_parent">
        <div class="col-md-4 sample-view" id="most_expressed">
        </div>
    </div>
    </div>
    <div class="container" id="least-expressed-samples">
    <h4>10 least expressed samples</h4>
    <div class="row">
        <div class="col-xs-6">
        <div class="text-right">
            <button type="button" class="btn btn-default toggle-genes">Sort genes alphabetically</button>
        </div>
        </div>
    </div>
    <div class="row" id="least_expressed_parent">
        <div class="col-md-4 sample-view" id="least_expressed">
        </div>
    </div>
    </div>
</body>

<script>
var edge_information = JSON.stringify({{ edge_info|safe }});
edge_information = JSON.parse(edge_information);
var most_expressed_data = 
    {"source_structures": edge_information["most_expressed_samples"],
     "target_structures": edge_information["gene_names"],
     "both_data": edge_information["most_expressed_heatmap"],
     "meta": edge_information["most_metadata"],
     "oddsratios": edge_information["odds_ratios"]};
var least_expressed_data =
    {"source_structures": edge_information["least_expressed_samples"],
     "target_structures": edge_information["gene_names"],
     "both_data": edge_information["least_expressed_heatmap"],
     "meta": edge_information["least_metadata"],
     "oddsratios": edge_information["odds_ratios"]};

function get_expression_minmax(data) {
    var min_expression = Math.min.apply(Math, data.map(function(d) { return d.value; }));
    var max_expression = Math.max.apply(Math, data.map(function(d) { return d.value; }));
    return {"min": min_expression, "max": max_expression};
}

function colorbar(expression_min, expression_max, colors) {
    var difference = expression_max - expression_min;
    var domain = [expression_min, expression_min + difference/3.0, expression_max - difference/3.0, expression_max];
    return d3.scale.linear().domain(domain).range(colors);
}

function index_sort(arr) {
    for (var i = 0; i < arr.length; i++) {
        arr[i] = [arr[i], i];
    }
    arr.sort(function(left, right) {
        return left[0] < right[0] ? -1 : 1;
    });
    arr.sortIndices = [];
    for (var j = 0; j < arr.length; j++) {
        arr.sortIndices.push(arr[j][1]);
            arr[j] = arr[j][0];
    }
    return arr;
}

function rearrange_by_indices(arr, index_arr) {
    var rearranged_arr = Array(arr.length);
    for (var i = 0; i < arr.length; i++) {
        rearranged_arr[i] = arr[index_arr[i]];
    }
    return rearranged_arr;
}

function rearrange_heatmap_indices(heatmap_data, index_arr) {
    var rearranged_heatmap_data = [];
    for (var i = 0; i < heatmap_data.length; i++) {
        var heatmap_obj = heatmap_data[i];
        var pos = heatmap_obj["target_index"];
        heatmap_obj["target_index"] = index_arr[pos];
        rearranged_heatmap_data.push(heatmap_obj);
    }
    return rearranged_heatmap_data;
}

var copy_most = jQuery.extend(true, {}, most_expressed_data);
var copy_least = jQuery.extend(true, {}, least_expressed_data);

function replace_with_alphabetical(copy_data) {
    var msorted_genes = index_sort(copy_data["target_structures"]);

    copy_data = {
        "source_structures": copy_data["source_structures"],
        "target_structures": msorted_genes,
        "both_data": rearrange_heatmap_indices(copy_data["both_data"], msorted_genes.sortIndices),
        "meta": copy_data["meta"],
        "oddsratios": rearrange_by_indices(copy_data["oddsratios"], msorted_genes.sortIndices)
    };
    return copy_data;
}

copy_most = replace_with_alphabetical(copy_most);
copy_least = replace_with_alphabetical(copy_least);

$(".toggle-genes").click(function() {
    $(this).text(function(i, text) {
        $("#most_expressed svg").remove();
        $("#least_expressed svg").remove();
        if (text == "Sort genes alphabetically") {
            append_heatmap("#most_expressed", copy_most, most_colorbar,
                   most_expressed_minmax["min"], most_expressed_minmax["max"]);
            append_heatmap("#least_expressed", copy_least, least_colorbar,
                   least_expressed_minmax["min"], least_expressed_minmax["max"]);
            return "Sort genes by odds ratio"; 
        } else {
            append_heatmap("#most_expressed", most_expressed_data, most_colorbar,
                   most_expressed_minmax["min"], most_expressed_minmax["max"]);
            append_heatmap("#least_expressed", least_expressed_data, least_colorbar,
                   least_expressed_minmax["min"], least_expressed_minmax["max"]);
            return "Sort genes alphabetically";
        }
    });

});

var most_expressed_minmax = get_expression_minmax(most_expressed_data["both_data"]);
var least_expressed_minmax = get_expression_minmax(least_expressed_data["both_data"]);

var most_colors = ["white", "yellow", "red", "black"];
var least_colors = ["white", "blue", "purple", "black"];

var most_colorbar = colorbar(most_expressed_minmax["min"], most_expressed_minmax["max"], most_colors); 
var least_colorbar = colorbar(least_expressed_minmax["min"], least_expressed_minmax["max"], least_colors);

function append_heatmap(div_id, data, color, min, max) {
    var width = 960, height = 800, 
        cell_size = 25, label_size = 100;

    var svg = d3.select(div_id).append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g");

    var meta_container = $("<div style='padding-top: 30px;'>").attr("class","meta col-md-6").prependTo($(div_id + "_parent"));
    meta_container.addClass("sample-view");
    function build_legend(chart_width, chart_height) {
        // Make an array of values, one for each pixel in the width of the legend.
        var legend_data = [];
        var num_elems = chart_width;
        for (var i = 0; i < num_elems; i++) { legend_data.push(i / num_elems); }

        // This scale handles interpolation between projection volume values and 
        // legend position.
        var legend_scale = d3.scale.linear()
            .domain([min,max])
            .range([0,chart_width]);
    
        // This object will generate the tick values along the bottom of the legend.
        var legend_axis = d3.svg.axis()
            .scale(legend_scale)
            .orient("bottom")
            .tickValues(color.domain());

        // Append the group that will hold all of the legend components.  A set of single-pixel
        // rectangles are drawn across the legend and colored by their interpolated color value.
        svg.append("g")
           .attr("class", "legend axis")
           .attr("transform", "translate(0,-100)")
           .call(legend_axis)
           .selectAll(".legend_cell")
           .data(legend_data)
           .enter().append("rect")
           .attr("x", function(d,i) { return i; })
           .attr("y", -cell_size)
           .attr("width", 1)
           .attr("height", cell_size)
           .attr("fill", function(d) { return color(d); });

        // A title for the legend.
        svg.append("text")
           .attr("x", chart_width / 2)
           .attr("y", -65)
           .attr("text-anchor", "middle")
           .text("normalized expression value");
    }


    var order = ["Sample", "Expression Value",
                 "Experiment", "Description", "Strain", "Genotype", "Medium (biosynthesis/energy)",
                 "Growth setting (planktonic, colony, biofilm)",
                 "Growth setting (For planktonic-aerated, static)(For biofilms-flow cell, static)",
                 "Treatment (drug/small molecule)", "Temperature",
                 "Biotic interactor_level 1 (Plant, Human, Bacteria)",
                 "Biotic interactor_level 2 (Lung, epithelial cells, Staphylococcus aureus, etc)",
                 "OD", "Nucleic Acid", "Variant phenotype (QS defective, mucoid, SCV, etc)",
                 "Abx marker, auxotrophy",
                 "Additional Notes (markers)", "EXPT SUMMARY",
                 "Gene-to-edge odds ratio"];
    // Construct the heatmap and its axes. The data supplied to this method
    // is an array of source-target volume values.  
    function build_heatmap(data, chart_width, chart_height) {

        // This group will hold all of the rectangles within the heatmap.
        var cell_group = svg.append("g");

        // Make a rectangle for each source-target projection volume value.
        var rects = cell_group.selectAll(".cell")
            .data(data.both_data)
            .enter().append("rect")
            .attr("x", function(d) { return d.source_index * cell_size; })
            .attr("y", function(d) { return d.target_index * cell_size; })
            .style("fill", function(d) { return color(d.value); })
            .attr("width", cell_size)
            .attr("height", cell_size)
            .on("mouseover", function(d) {
                var sample_name = data.source_structures[d.source_index];
                var metadata = JSON.parse(data.meta[sample_name]);
                if (!metadata) {
                    metadata = {};
                }
                metadata["Expression Value"] = Math.ceil(d.value * 1000.0) / 1000.0;
                metadata["Gene-to-edge odds ratio"] = Math.ceil(data.oddsratios[d.target_index] * 1000.0) / 1000.0;
                var metadata_html = "<table class='table table-sm'><thead><tr><th style='width: 30%;'></th>"
                + "<th style='width: 70%;'></th></tr></thead><tbody>"; 

                for (var i = 0; i < order.length; i++) {
                    var key = order[i];
                    if (key in metadata) {
                        metadata_html += "<tr><td style='line-height: 0.9;'><strong>" + key + "</strong></td>"
                                           + "<td style='line-height: 0.9;'>" + metadata[key] + "</td></tr>";
                    }
                }
                metadata_html += "</tbody>";

                /*
                var build_html = "";
                build_html = "<p class='font-weight-bold font-italic'>" + sample_name + "<br />" +
                    data.target_structures[d.target_index] + "</p>" +
                    "<p class='font-weight-normal'>" + "<strong>expression value:</strong> " +
                    Math.ceil(d.value * 1000.0) / 1000.0 +
                    "<br />" + "<strong>odds ratio:</strong> " +
                    Math.ceil(data.oddsratios[d.target_index] * 1000.0) / 1000.0 + "</p>" +
                    "<p>" + metadata_html + "</p>";
                */
                meta_container.html(metadata_html);
                if (metadata_html.length != 0) {
                    d3.select(this)
                      .style("stroke", "black")
                      .style("opacity", "0.6");
                }
            })
            .on("mouseout", function(d) {
                d3.select(this)
                  .style("opacity", "1")
                  .style("stroke", color(d.value));
            })
            .on("click", function(d) {
                var sample_name = data.source_structures[d.source_index];
                var metadata = JSON.parse(data.meta[sample_name]);
                var experiment = metadata["Experiment"];
                var xhr = new XMLHttpRequest();
                window.location.href = window.location.href + "/experiment/" + experiment;
            });

        // Construct text labels for the y axis
        svg.append("g")
           .attr("class", "y axis")
           .selectAll("text")
           .data(data.target_structures)
           .enter().append("text")
           .attr("y", function(d,i) { return i * cell_size + 17.5; })
           .attr("x", -5)
           .attr("text-anchor", "end")
           .attr("fill", function(d, i) {
                var owner = edge_information["ownership"][i];
                if (owner == 0) {
                    return "pink";
                } else if (owner == 1) {
                    return "green";
                }
           })
           .text(function(d) { return d; });

        // Construct text labels for the x axis
        svg.append("g")
           .attr("class", "x axis")
           .attr("transform", "translate(0,"+ chart_height +")")
           .selectAll("text")
           .data(data.source_structures)
           .enter().append("text")
           .attr("transform", function(d,i) { 
                var x = (i * cell_size);
                var y = 0;
                return "translate("+ (x + 8) + "," + (y + 5) + ") rotate(90)" ; 
           })
           .text(function(d) { return d; });

        // A title for the x axis.
        svg.append("text")
           .attr("x", chart_width / 2)
           .attr("y", -20)
           .attr("text-anchor", "middle")
           .text("Samples");

        // A title for the y axis.
        svg.append("text")
           .attr("text-anchor", "middle")
           .attr("transform","translate(-" + (chart_width / 3) + "," + (chart_height / 2) +") rotate(90)")
           .text("Genes");
    }
    var chart_height = cell_size * data.target_structures.length;
    var chart_width = cell_size * data.source_structures.length;
    
    build_heatmap(data, chart_width, chart_height);
    build_legend(chart_width, chart_height);

    bounding = svg.node().getBBox();
    svg.attr("transform", "translate("
                         + bounding.x * -1 + ","
                         + bounding.y * -1 + ")");
    
    d3.select("svg").attr("width", bounding.width);
    d3.select("svg").attr("height", bounding.height);
}

append_heatmap("#most_expressed", most_expressed_data, most_colorbar,
               most_expressed_minmax["min"], most_expressed_minmax["max"]);
append_heatmap("#least_expressed", least_expressed_data, least_colorbar,
               least_expressed_minmax["min"], least_expressed_minmax["max"]);


</script>
</html>
