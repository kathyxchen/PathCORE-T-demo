<head>
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css"
integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

<script src="https://code.jquery.com/jquery-3.1.1.slim.min.js"
integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>

<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"
integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="{{ url_for('static', filename='js/d3.v3.min.js') }}"></script>
</head>
<body>
    <div id="overview" class="container">
        <div class="row">
        <h2>{{edge_str}}</h2>
        <h5><a href="{{ url_for('ppin_network') }}">Return to network</a></h5>
        <p>
            If a gene-by-sample square has an experiment associated with it (on hover), you can click on
            that square to view the gene expression values for all samples from that experiment.
        </p>
        </div>
    </div>
    <div class="container" id="most-expressed-samples">
    <h4>10 most expressed samples</h4>
    <div class="row" id="most_expressed_parent">
        <div class="col-md-2" id="most_comments">
            <form>
                <div class="form-group">
                    <label for="exampleTextarea">Example textarea</label>
                    <textarea class="form-control" id="exampleTextarea" rows="3"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">Submit</button>
            </form>
        </div>
        <div class="col-md-6" id="most_expressed">
        </div>
    </div>
    </div>
    <div class="container" id="least-expressed-samples">
    <h4>10 least expressed samples</h4>
    <div class="row" id="least_expressed_parent">
        <div class="col-md-8" id="least_expressed">
        </div>
    </div>
    </div>
</body>
<script>
var edge_information = JSON.parse({{ edge_info|tojson }});
var most_expressed_data = 
    {"source_structures": edge_information["most_expressed_samples"],
     "target_structures": edge_information["gene_names"],
     "both_data": edge_information["most_expressed_objs"],
     "meta": edge_information["most_metadata"],
     "oddsratios": edge_information["oddsratios"]};
var least_expressed_data =
    {"source_structures": edge_information["least_expressed_samples"],
     "target_structures": edge_information["gene_names"],
     "both_data": edge_information["least_expressed_objs"],
     "meta": edge_information["least_metadata"],
     "oddsratios": edge_information["oddsratios"]};

var most_expr_min = Math.min.apply(Math, most_expressed_data["both_data"].map(function(d) { return d.value; }));
var most_expr_max = Math.max.apply(Math, most_expressed_data["both_data"].map(function(d) { return d.value; }));

var least_expr_min = Math.min.apply(Math, least_expressed_data["both_data"].map(function(d) { return d.value; }));
var least_expr_max = Math.max.apply(Math, least_expressed_data["both_data"].map(function(d) { return d.value; }));

var most_colors = ["white", "yellow", "red", "black"];
var least_colors = ["white", "blue", "purple", "black"];

function colorbar(expression_min, expression_max, colors) {
    var difference = expression_max - expression_min;
    var domain = [expression_min, expression_min + difference/3.0, expression_max - difference/3.0, expression_max];
    return d3.scale.linear().domain(domain).range(colors);
}

var most_colorbar = colorbar(most_expr_min, most_expr_max, most_colors); 
var least_colorbar = colorbar(least_expr_min, least_expr_max, least_colors);

function append_heatmap(div_id, data, color, min, max) {
    var width = 960, height = 800, 
        cell_size = 25, label_size = 100;

    var svg = d3.select(div_id).append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g");

    var meta_container = $("<div style='padding-top: 30px;'>").attr("class","meta col-md-4").appendTo($(div_id + "_parent"));
    // Build the D3 components that display the heatmap color legend.
    function build_legend(chart_width, chart_height) {
        // Make an array of values, one for each pixel in the width of the legend.
        var legend_data = [];
        var num_elems = chart_width;
        for (var i = 0; i < num_elems; i++) { legend_data.push(i / num_elems * 1); }

        // This scale handles interpolation between projection volume values and 
        // legend position.
        var legend_scale = d3.scale.linear()
            .domain([min,max])
            .range([0,chart_width]);
    
        // This object will generate the tick values along the bottom of the legend.
        var legend_axis = d3.svg.axis()
            .scale(legend_scale)
            .orient("bottom")
            .tickValues(color.domain());

        // Append the group that will hold all of the legend components.  A set of single-pixel
        // rectangles are drawn across the legend and colored by their interpolated color value.
        svg.append("g")
           .attr("class", "legend axis")
           .attr("transform", "translate(0,-100)")
           .call(legend_axis)
           .selectAll(".legend_cell")
           .data(legend_data)
           .enter().append("rect")
           .attr("x", function(d,i) { return i; })
           .attr("y", -cell_size)
           .attr("width", 1)
           .attr("height", cell_size)
           .attr("fill", function(d) { return color(d); });

        // A title for the legend.
        svg.append("text")
           .attr("x", chart_width / 2)
           .attr("y", -65)
           .attr("text-anchor", "middle")
           .text("normalized expression value");
    }

    // Construct the heatmap and its axes. The data supplied to this method
    // is an array of source-target volume values.  
    function build_heatmap(data, chart_width, chart_height) {

        // This group will hold all of the rectangles within the heatmap.
        var cell_group = svg.append("g");

        // Make a rectangle for each source-target projection volume value.
        var rects = cell_group.selectAll(".cell")
            .data(data.both_data)
            .enter().append("rect")
            .attr("x", function(d) { return d.source_index * cell_size; })
            .attr("y", function(d) { return d.target_index * cell_size; })
            .style("fill", function(d) { return color(d.value); })
            .attr("width", cell_size)
            .attr("height", cell_size)
            .on("mouseover", function(d) {
                var sample_name = data.source_structures[d.source_index];
                var metadata = JSON.parse(data.meta[sample_name]);
                var metadata_html = "";
                for (var key in metadata) {
                    metadata_html += "<strong>" + key + "</strong>: " + metadata[key] + "<br />";
                }
                var build_html = "";
                build_html = "<p class='font-weight-bold font-italic'>" + sample_name + "<br />" +
                    data.target_structures[d.target_index] + "</p>" +
                    "<p class='font-weight-normal'>" + "<strong>expression value:</strong> " +
                    Math.ceil(d.value * 1000.0) / 1000.0 +
                    "<br />" + "<strong>odds ratio:</strong> " +
                    Math.ceil(data.oddsratios[d.target_index] * 1000.0) / 1000.0 + "</p>" +
                    "<p>" + metadata_html + "</p>";
                meta_container.html(build_html);
                if (metadata_html.length != 0) {
                    d3.select(this)
                      .style("stroke", "black")
                      .style("opacity", "0.6");
                }
            })
            .on("mouseout", function(d) {
                d3.select(this)
                  .style("opacity", "1")
                  .style("stroke", color(d.value));
            })
            .on("click", function(d) {
                var sample_name = data.source_structures[d.source_index];
                var metadata = JSON.parse(data.meta[sample_name]);
                var experiment = metadata["Experiment"];
                var xhr = new XMLHttpRequest();
                window.location.href = window.location.href + "/experiment/" + experiment;
            });

        // Construct text labels for the y axis
        svg.append("g")
           .attr("class", "y axis")
           .selectAll("text")
           .data(data.target_structures)
           .enter().append("text")
           .attr("y", function(d,i) { return i * cell_size + 17.5; })
           .attr("x", -5)
           .attr("text-anchor", "end")
           .text(function(d) { return d; });

        // Construct text labels for the x axis
        svg.append("g")
           .attr("class", "x axis")
           .attr("transform", "translate(0,"+ chart_height +")")
           .selectAll("text")
           .data(data.source_structures)
           .enter().append("text")
           .attr("transform", function(d,i) { 
                var x = (i * cell_size);
                var y = 0;
                return "translate("+ (x + 8) + "," + (y + 5) + ") rotate(90)" ; 
           })
           .text(function(d) { return d; });

        // A title for the x axis.
        svg.append("text")
           .attr("x", chart_width / 2)
           .attr("y", -20)
           .attr("text-anchor", "middle")
           .text("Samples");

        // A title for the y axis.
        svg.append("text")
           .attr("text-anchor", "middle")
           .attr("transform","translate(-" + (chart_width / 2) + "," + (chart_height / 2) +") rotate(90)")
           .text("Genes");
    }
    var chart_height = cell_size * data.target_structures.length;
    var chart_width = cell_size * data.source_structures.length;
    /*
    svg.attr("transform", "translate(" + 
        + ((width / 2) - (chart_width / 2)) + "," 
        + ((height / 4) - (chart_height / 4)) + ")");
    */
    build_heatmap(data, chart_width, chart_height);
    build_legend(chart_width, chart_height);

    bounding = svg.node().getBBox();
    console.log(bounding);
    svg.attr("transform", "translate(" +
              bounding.x * -1 + "," +
              bounding.y * -1 + ")"
            );
    
    d3.select("svg").attr("width", bounding.width);
    d3.select("svg").attr("height", bounding.height);
}

append_heatmap("#most_expressed", most_expressed_data, most_colorbar, most_expr_min, most_expr_max);
append_heatmap("#least_expressed", least_expressed_data, least_colorbar, least_expr_min, least_expr_max);

</script>
</html>
