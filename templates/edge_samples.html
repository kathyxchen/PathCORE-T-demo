{% extends "layout.html" %}
{% block title %}{% endblock %}
{% block head %}
  {{ super() }}
  <style>
  .pw1 {
   color: pink;
  }

  .pw2 {
   color: green;
  }

  .both {
    color: purple;
  }
  </style>
{% endblock %}
{% block content %}
<div id="overview" class="container">
    <div class="row">
        <h2>
          <span class="pw1">{{pw1}}</span> 
          <span class="pw2">{{pw2}}</span>
        </h2>
        <h3>
          <a href="{{ url_for('pathcore_network') }}">Return to network</a>
        </h3>
        <h3 class="description">Description</h3>
        <p>
            For every gene annotated to one or both of {{pw1}} and {{pw2}},
            we computed an odds ratio that measures how often we observe a
            feature enriched for both the gene and the edge of interest.
            This page displays a maximum of 20 genes that had an odds
            ratio of above 1. 
            We do this to highlight the genes that are most observed
            with the current pathway co-occurrence relationship.
        </p>
        <p>        
            A summary expression score per sample was determined based on
            the normalized expression values of the selected genes,
            where each expression value was weighted by the corresponding
            gene's odds ratio.
            Displayed are the <a href="#most-expressed-samples">
              20 most expressed</a>
            and <a href="#least-expressed-samples">
              20 least expressed</a> samples. 
        </p>
        <p>
            If a gene-by-sample square has an experiment associated with
            it (the information shows up when you hover over the square),
            you can <b>click through</b> to view an <b>experiment page</b>
            that displays the selected genes' expression values for
            all samples from that experiment.
        </p>
        <p>
            When available, we provide the common name for a given PA
            gene locus tag. Genes in <span class="pw1">pink</span> are
            annotated to <span class="pw1">{{pw1}}</span> in KEGG,
            <span class="pw2">green</span> to <span class="pw2">{{pw2}}</span>,
            and <span class="both">purple</span> to
            <span class="both">both</span>.
        </p>
        <h4>
          <a href="{{ url_for('edge_excel_file', edge_pws=pw1 + '&' + pw2) }}">
            Click here to download a .csv file of the data provided in the
            two heatmaps.
          </a>
        </h4>
    </div>
</div>
<div class="container" id="most-expressed-samples">
<h4>20 most expressed samples</h4>
<div class="row">
    <div class="col-xs-6">
    <div class="text-right">
      <button type="button" class="btn btn-default toggle-genes">
        Sort genes alphabetically
      </button>
    </div>
    </div>
</div>
<div class="row" id="most_expressed_parent">
    <div class="col-md-4 sample-view" id="most_expressed">
    </div>
</div>
</div>
<div class="container" id="least-expressed-samples">
<h4>20 least expressed samples</h4>
<div class="row">
    <div class="col-xs-6">
    <div class="text-right">
        <button type="button" class="btn btn-default toggle-genes">
          Sort genes alphabetically
        </button>
    </div>
    </div>
</div>
<div class="row" id="least_expressed_parent">
    <div class="col-md-4 sample-view" id="least_expressed">
    </div>
</div>
</div>

<script type="text/javascript">
const edgeInfo = JSON.parse(JSON.stringify({{ edge_info|safe }}));

const mostExpressedData = 
    {"samplesX": edgeInfo["most_expressed_samples"],
     "genesY": edgeInfo["gene_names"],
     "heatmapData": edgeInfo["most_expressed_heatmap"],
     "meta": edgeInfo["most_metadata"],
     "oddsratios": edgeInfo["odds_ratios"],
     "ownership": edgeInfo["ownership"]
    };
const leastExpressedData =
    {"samplesX": edgeInfo["least_expressed_samples"],
     "genesY": edgeInfo["gene_names"],
     "heatmapData": edgeInfo["least_expressed_heatmap"],
     "meta": edgeInfo["least_metadata"],
     "oddsratios": edgeInfo["odds_ratios"],
     "ownership": edgeInfo["ownership"]
    };


const mostExprMinMax = expressionMinMax(mostExpressedData["heatmapData"]);
const leastExprMinMax = expressionMinMax(leastExpressedData["heatmapData"]);

const mostExprColors = ["white", "yellow", "red", "black"];
const leastExprColors = ["white", "blue", "purple", "black"];

const mostExprColorbar = colorbar(
  mostExprMinMax["min"], mostExprMinMax["max"], mostExprColors); 
const leastExprColorbar = colorbar(
  leastExprMinMax["min"], leastExprMinMax["max"], leastExprColors);

const copyMost = replaceWithAlphabetical(
  jQuery.extend(true, {}, mostExpressedData));
const copyLeast = replaceWithAlphabetical(
  jQuery.extend(true, {}, leastExpressedData));

const sampleMetadataRows = [
  "Sample", "Expression Value", "Experiment", "Description",
  "Strain", "Genotype", "Medium (biosynthesis/energy)",
  "Growth setting (planktonic, colony, biofilm)",
  "Growth setting (For planktonic-aerated, static)" +
    "(For biofilms-flow cell, static)",
  "Treatment (drug/small molecule)", "Temperature",
  "Biotic interactor_level 1 (Plant, Human, Bacteria)",
  "Biotic interactor_level 2 (Lung, epithelial cells, " +
    "Staphylococcus aureus, etc)",
  "OD", "Nucleic Acid", "Variant phenotype (QS defective, mucoid, SCV, etc)",
  "Abx marker, auxotrophy", "Additional Notes (markers)", "EXPT SUMMARY",
  "Gene-to-edge odds ratio"
];

const mostExprHeatmap = createHeatmap("#most_expressed",
  mostExpressedData, mostExprColorbar,
  mostExprMinMax["min"], mostExprMinMax["max"]);
const leastExprHeatmap = createHeatmap("#least_expressed",
  leastExpressedData, leastExprColorbar,
  leastExprMinMax["min"], leastExprMinMax["max"]);

mostExprHeatmap.prependTo($("#most_expressed_parent"));
leastExprHeatmap.prependTo($("#least_expressed_parent"));

function expressionMinMax(data) {
    const minExpression = Math.min.apply(
      Math, data.map(function(d) { return d.value; }));
    const maxExpression = Math.max.apply(
      Math, data.map(function(d) { return d.value; }));
    return {"min": minExpression, "max": maxExpression};
}

function colorbar(minExpression, maxExpression, colors) {
    const difference = maxExpression - minExpression;
    const domain = [
      minExpression,
      minExpression + difference / 3.0,
      maxExpression - difference / 3.0,
      maxExpression];
    return d3.scale.linear().domain(domain).range(colors);
}

function indexSort(arr) {
    for (let i = 0; i < arr.length; i++) {
      arr[i] = [arr[i], i];
    }
    arr.sort(function(left, right) {
      return left[0] < right[0] ? -1 : 1;
    });
    arr.indicesSorted = [];
    for (let j = 0; j < arr.length; j++) {
      arr.indicesSorted.push(arr[j][1]);
      arr[j] = arr[j][0];
    }
    return arr;
}

function rearrangeByIndices(arr, indexArr) {
    let rearrangedArr = Array(arr.length);
    for (let i = 0; i < arr.length; i++) {
      rearrangedArr[i] = arr[indexArr[i]];
    }
    return rearrangedArr;
}

function rearrangeHeatmapIndices(heatmapData, indexArr) {
    let rearrangedHeatmapData = [];
    let heatmapCells = {};
    
    for (let i = 0; i < heatmapData.length; i++) {
      let cell = heatmapData[i];
      let key = cell.source_index + " " + cell.target_index;
      heatmapCells[key] = cell.value;
    }

    for (let i = 0; i < heatmapData.length; i++) {
      let heatmapCell = {};
      let currentGenePos = heatmapData[i]["target_index"];

      heatmapCell["source_index"] = heatmapData[i]["source_index"];
      heatmapCell["target_index"] = heatmapData[i]["target_index"];
      heatmapCell["value"] = heatmapCells[heatmapCell.source_index + " " +
                                          indexArr[currentGenePos]];
      rearrangedHeatmapData.push(heatmapCell);
    }

    return rearrangedHeatmapData;
}

function replaceWithAlphabetical(copyData) {
    alphabeticalGenes = indexSort(copyData["genesY"]);
    copyData = {
        "samplesX": copyData["samplesX"],
        "genesY": alphabeticalGenes,
        "heatmapData": rearrangeHeatmapIndices(
          copyData["heatmapData"], alphabeticalGenes.indicesSorted),
        "meta": copyData["meta"],
        "oddsratios": rearrangeByIndices(
          copyData["oddsratios"], alphabeticalGenes.indicesSorted),
        "ownership": rearrangeByIndices(
          copyData["ownership"], alphabeticalGenes.indicesSorted)
    };
    return copyData;
}

/* listener for the button toggle
 * (genes ordered by odds ratio or alphabetically)
 */
$(".toggle-genes").click(function() {
    $(".toggle-genes").text(function(i, text) {
        let x;
        let y;
        let returnButtonLabel;

        $("#most_expressed svg").remove();
        $("#least_expressed svg").remove();
        
        if (text == "Sort genes alphabetically") {
            x = createHeatmap("#most_expressed",
              copyMost, mostExprColorbar,
              mostExprMinMax["min"], mostExprMinMax["max"]);
            y = createHeatmap("#least_expressed",
              copyLeast, leastExprColorbar,
              leastExprMinMax["min"], leastExprMinMax["max"]);
            //$("#most_expressed_parent .meta.sample-view").replaceWith(x);
            //$("#least_expressed_parent .meta.sample-view").replaceWith(y);
            returnButtonLabel = "Sort genes by odds ratio"; 
        } else {
            x = createHeatmap("#most_expressed",
              mostExpressedData, mostExprColorbar,
              mostExprMinMax["min"], mostExprMinMax["max"]);
            y = createHeatmap("#least_expressed",
              leastExpressedData, leastExprColorbar,
              leastExprMinMax["min"], leastExprMinMax["max"]);
            //$("#most_expressed_parent .meta.sample-view").replaceWith(x);
            //$("#least_expressed_parent .meta.sample-view").replaceWith(y);
            returnButtonLabel = "Sort genes alphabetically";
        }
        $("#most_expressed_parent .meta.sample-view").replaceWith(x);
        $("#least_expressed_parent .meta.sample-view").replaceWith(y);
        return returnButtonLabel;
    });

});

function createHeatmap(divId, data, color, min, max) {
  const width = 960;
  const height = 800;
  const cellSize = 25;
  const labelSize = 100;

  const heatmapHeight = cellSize * data.genesY.length;
  const heatmapWidth = cellSize * data.samplesX.length;

  const svg = d3.select(divId).append("svg")
    .attr("width", width)
    .attr("height", height)
    .append("g");

  const container = $("<div style='padding-top: 30px;'>")
    .attr("class","meta col-md-6")
    .addClass("sample-view");

  let bounding;

  function heatmapLegend(heatmapWidth, heatmapHeight) {
    const legendWidth = Math.max(Math.min(chart_width, 500), 100);
    let colorbarLegend = [];
    for (var i = 0; i < legendWidth; i++) { 
      colorbarLegend.push(i / legendWidth); 
    }

    // handles interpolation between expression values and legend position
    var legendScale = d3.scale.linear()
      .domain([min,max])
      .range([0,legendWidth]);
  
    // generates the tick values along the bottom of the legend
    var legendAxis = d3.svg.axis()
      .scale(legendScale)
      .orient("bottom")
      .tickValues(color.domain());

    // a set of single-pixel rectangles are drawn across the legend and
    // colored by their interpolated color value
    svg.append("g")
      .attr("class", "legend axis")
      .attr("transform", "translate(0,-100)")
      .call(legendAxis)
      .selectAll(".legend_cell")
      .data(colorbarLegend)
      .enter().append("rect")
      .attr("x", function(d,i) { return i; })
      .attr("y", -cellSize)
      .attr("width", 1)
      .attr("height", cellSize)
      .attr("fill", function(d) { return color(d); });

    // legend title
    svg.append("text")
       .attr("x", legendWidth / 2)
       .attr("y", -65)
       .attr("text-anchor", "middle")
       .text("normalized expression value");
  }
  
  function heatmap(data, heatmapWidth, heatmapHeight) {
    // holds all of the rectangles in the heatmap
    const cellGroup = svg.append("g");
    const rects = cellGroup.selectAll(".cell")
      .data(data.heatmapData)
      .enter().append("rect")
      .attr("x", function(d) { return d.source_index * cellSize; })
      .attr("y", function(d) { return d.target_index * cellSize; })
      .style("fill", function(d) { return color(d.value); })
      .attr("width", cellSize)
      .attr("height", cellSize)
      .on("mouseover", function(d) {
        const sampleName = data.samplesX[d.source_index];
        const metadata = JSON.parse(data.meta[sampleName]);
        let metadataHtml;

        if (!metadata) {
            metadata = {};
        }
        metadata["Expression Value"] = Math.ceil(d.value * 1000.0) / 1000.0;
        metadata["Gene-to-edge odds ratio"] = Math.ceil(
          data.oddsratios[d.target_index] * 1000.0) / 1000.0;
        metadataHtml = "<table class='table table-sm'>" +
          "<thead><tr><th style='width: 30%;'></th>" + 
          "<th style='width: 70%;'></th></tr></thead><tbody>"; 

        for (let i = 0; i < sampleMetadataRows.length; i++) {
            const key = sampleMetadataRows[i];
            if (key in metadata) {
                metadataHtml += "<tr><td style='line-height: 0.9;'><strong>" +
                  key + "</strong></td>" +
                  "<td style='line-height: 0.9;'>" + 
                  metadata[key] + 
                  "</td></tr>";
            }
        }
        metadataHtml += "</tbody>";
        container.html(metadataHtml);
        if (metadataHtml.length != 0) {
          d3.select(this)
            .style("stroke", "black")
            .style("opacity", "0.6");
        }
      })
      .on("mouseout", function(d) {
        d3.select(this)
          .style("opacity", "1")
          .style("stroke", color(d.value));
      })
      .on("click", function(d) {
        const sampleName = data.samplesX[d.source_index];
        const metadata = JSON.parse(data.meta[sampleName]);
        const experiment = metadata["Experiment"];
        const xhr = new XMLHttpRequest();
        window.location.href += "/experiment/" + experiment + "&" +
          divId.substring(1);
      });

    // construct text labels for the y axis
    svg.append("g")
      .attr("class", "y axis")
      .selectAll("text")
      .data(data.genesY)
      .enter().append("text")
      .attr("y", function(d,i) { return i * cellSize + 17.5; })
      .attr("x", -5)
      .attr("text-anchor", "end")
      .attr("fill", function(d, i) {
          const owner = data.ownership[i];
          if (owner == 0) {
              return "pink";
          } else if (owner == 1) {
              return "green";
          } else {
              return "purple";
          }
      })
      .text(function(d) { return d; });

    // construct text labels for the x axis
    svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0,"+ heatmapHeight +")")
      .selectAll("text")
      .data(data.samplesX)
      .enter().append("text")
      .attr("transform", function(d,i) { 
        var x = (i * cellSize);
        var y = 0;
        return "translate("+ (x + 8) + "," + (y + 5) + ") rotate(90)" ; 
      })
      .text(function(d) { return d; })
      .style("fill", function(d) {
        if ("whitelist" in data) {
          if (data.whitelist.hasOwnProperty("most") 
              && $.inArray(d, data.whitelist.most) > -1) {
              return "red";
          }
          if (data.whitelist.hasOwnProperty("least")
              && $.inArray(d, data.whitelist.least) > -1) {
              return "blue";
          }
        }
        return 'black';
      });

    // title for the x axis
    svg.append("text")
     .attr("x", heatmapWidth / 2)
     .attr("y", -20)
     .attr("text-anchor", "middle")
     .text("Samples");

    // title for the y axis
    svg.append("text")
     .attr("text-anchor", "middle")
     .attr("transform","translate(-" + (heatmapWidth / 3) + "," +
                       (heatmapHeight / 2) +") rotate(90)")
     .text("Genes");
  }
  
  heatmap(data, heatmapWidth, heatmapHeight);
  heatmapLegend(heatmapWidth, heatmapHeight);

  bounding = svg.node().getBBox();
  svg.attr("transform", "translate("
                       + bounding.x * -1 + ","
                       + bounding.y * -1 + ")");
  
  d3.select("svg").attr("width", bounding.width);
  d3.select("svg").attr("height", bounding.height);
  return container;
}
</script>
{% endblock %}
