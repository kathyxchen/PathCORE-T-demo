<head>
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css"
integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

<script src="https://code.jquery.com/jquery-3.1.1.slim.min.js"
integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>

<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"
integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="{{ url_for('static', filename='js/d3.v3.min.js') }}"></script>
</head>
<body>
    <div id="overview">
    </div>
    <div class="container">
        <h3>Experiment {{ experiment_name }}</h3>
        <div class="row" id="heatmap_parent">
        <div class="col-xs-8" id="heatmap">
        </div>
        </div>
    </div>
</body>
<script>
var heatmap_information = JSON.parse({{ experiment_information|tojson }});

var sample_data = heatmap_information["all_samples"];
var sample_names = Object.keys(sample_data);
var build_indices = [];
for (var i = 0; i < sample_names.length; i++) {
    var sample = sample_names[i];
    var expr_values = sample_data[sample_names[i]];
    for (var j = 0; j < expr_values.length; j++) {
        value = expr_values[j];
        var coordinate = {};
        coordinate["source_index"] = i;
        coordinate["target_index"] = j;
        coordinate["value"] = value;
        build_indices.push(coordinate);
    }
}

var data = 
    {"source_structures": sample_names,
     "target_structures": heatmap_information["genes"],
     "both_data": build_indices,
     "meta": heatmap_information["metadata_samples"],
     "whitelist": heatmap_information["whitelist_samples"]
    };

var colors = ["white", "yellow", "green", "black"];

var colorbar = d3.scale.linear().domain([0, 0.25, 0.50, 1.0]).range(colors);

function append_heatmap(div_id, data, color, min, max) {
    var width = 960, height = 600, 
        cell_size = 25, label_size = 100;

    var svg = d3.select(div_id).append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g");

    var meta_container = $("<div class='col-xs-4'>").attr("class","meta").appendTo($(div_id + "_parent"));
    // Build the D3 components that display the heatmap color legend.
    function build_legend(chart_width, chart_height) {
        // Make an array of values, one for each pixel in the width of the legend.
        var legend_data = [];
        var num_elems = chart_width;
        for (var i = 0; i < num_elems; i++) { legend_data.push(i / num_elems * 1); }

        // This scale handles interpolation between projection volume values and 
        // legend position.
        var legend_scale = d3.scale.linear()
            .domain([min,max])
            .range([0,chart_width]);
    
        // This object will generate the tick values along the bottom of the legend.
        var legend_axis = d3.svg.axis()
            .scale(legend_scale)
            .orient("bottom")
            .tickValues(color.domain());

        // Append the group that will hold all of the legend components.  A set of single-pixel
        // rectangles are drawn across the legend and colored by their interpolated color value.
        svg.append("g")
           .attr("class", "legend axis")
           .attr("transform", "translate(0,-70)")
           .call(legend_axis)
           .selectAll(".legend_cell")
           .data(legend_data)
           .enter().append("rect")
           .attr("x", function(d,i) { return i; })
           .attr("y", -cell_size)
           .attr("width", 1)
           .attr("height", cell_size)
           .attr("fill", function(d) { return color(d); });

        // A title for the legend.
        svg.append("text")
           .attr("x", chart_width / 2)
           .attr("y", -101)
           .attr("text-anchor", "middle")
           .text("normalized expression value");

    }

    // Construct the heatmap and its axes. The data supplied to this method
    // is an array of source-target volume values.  
    function build_heatmap(data, chart_width, chart_height) {

        // This group will hold all of the rectangles within the heatmap.
        var cell_group = svg.append("g");

        // Make a rectangle for each source-target projection volume value.
        var rects = cell_group.selectAll(".cell")
            .data(data.both_data)
            .enter().append("rect")
            //.attr("x", function(d) { return d.target_index * cell_size; })
            //.attr("y", function(d) { return d.source_index * cell_size; })
            .attr("x", function(d) { return d.source_index * cell_size; })
            .attr("y", function(d) { return d.target_index * cell_size; })
            .style("fill", function(d) { return color(d.value); })
            .attr("width", cell_size)
            .attr("height", cell_size)
            .on("mouseover", function(d) {
                var sample_name = data.source_structures[d.source_index];
                var metadata = data.meta[sample_name];
                var metadata_html = ""
                for (var key in metadata) {
                    metadata_html += "<strong>" + key + "</strong>: " + metadata[key] + "<br />";
                }
                meta_container.html("<div style='text-decoration: underline;'>" + sample_name +
                                    " [ " + data.target_structures[d.target_index] + " ]</div>" + 
                                    "<div><strong>" +
                                    "expression:</strong> " + d.value + "</div>" +
                                    "<div class='value'>" +
                                    metadata_html + "</div></div>");
                });

        // Construct text labels for the y axis
        svg.append("g")
           .attr("class", "y axis")
           .selectAll("text")
           .data(data.target_structures)
           .enter().append("text")
           .attr("y", function(d,i) { return i * cell_size + 17.5; })
           .attr("x", -5)
           .attr("text-anchor", "end")
           .text(function(d) { return d; });

        // Construct text labels for the x axis
        svg.append("g")
           .attr("class", "x axis")
           .attr("transform", "translate(0,"+ chart_height +")")
           .selectAll("text")
           .data(data.source_structures)
           .enter().append("text")
           .attr("transform", function(d,i) { 
                var x = (i * cell_size);
                var y = 0;
                return "translate("+ (x + 8) + "," + (y + 5) + ") rotate(90)" ; 
           })
           .text(function(d) { return d; });

        // A title for the x axis.
        svg.append("text")
           .attr("x", chart_width / 2)
           .attr("y", chart_height + 130)
           .attr("text-anchor", "middle")
           .text("Samples");

        // A title for the y axis.
        svg.append("text")
           .attr("text-anchor", "middle")
           .attr("transform","translate(-110," + (chart_height / 2) +") rotate(90)")
           .text("Genes");
    }
    var chart_height = cell_size * data.target_structures.length;
    var chart_width = cell_size * data.source_structures.length;

    svg.attr("transform", "translate(" + 
        + ((width / 2) - (chart_width / 2)) + "," 
        + ((height / 2) - (chart_height / 2)) + ")");

    build_heatmap(data, chart_width, chart_height);
    build_legend(chart_width, chart_height);
}

append_heatmap("#heatmap", data, colorbar, 0.0, 1.0);

</script>
</html>
