<head>
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css"
integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"
integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="{{ url_for('static', filename='js/d3.v3.min.js') }}"></script>
</head>
<body>
    <div id="overview">
    </div>
    <div class="container">
        <h3>Experiment {{ experiment_name }}</h3>
        <div class="row" id="heatmap_parent">
        <div class="col-md-8" id="heatmap" style="overflow-x: scroll;">
        </div>
        </div>
    </div>
</body>
<script type="text/javascript">
var heatmap_information = JSON.parse({{ experiment_information|tojson }});
console.log(heatmap_information);
var sample_data = heatmap_information["sample_values"];
var samples = heatmap_information["samples"];
// additional sorting step because odds ratio ordering was based on
// more genes than what we have now...
var whitelisted = heatmap_information["whitelist_samples"];
var final_sorted_samples = [];
var least = [];
if (whitelisted.hasOwnProperty("most")) {
    final_sorted_samples = final_sorted_samples.concat(whitelisted["most"]);
}
if (whitelisted.hasOwnProperty("least")) {
    least = whitelisted["least"];
}
for (var i = 0; i < samples.length; i++) {
    if ($.inArray(samples[i], final_sorted_samples) == -1
        && $.inArray(samples[i], least) == -1) {
        final_sorted_samples.push(samples[i]);
    }
}
final_sorted_samples = final_sorted_samples.concat(least);

var sample_names = final_sorted_samples;
var build_indices = [];
for (var i = 0; i < sample_names.length; i++) {
    var sample = sample_names[i];
    var expr_values = sample_data[sample];
    for (var j = 0; j < expr_values.length; j++) {
        value = expr_values[j];
        var coordinate = {};
        coordinate["source_index"] = i;
        coordinate["target_index"] = j;
        coordinate["value"] = value;
        build_indices.push(coordinate);
    }
}

var data = 
    {"source_structures": sample_names,
     "target_structures": heatmap_information["genes"],
     "both_data": build_indices,
     "whitelist": heatmap_information["whitelist_samples"],
     "oddsratios": heatmap_information["oddsratios"]
    };

var colors = ["white", "yellow", "green", "black"];

var colorbar = d3.scale.linear().domain([0, 0.25, 0.50, 1.0]).range(colors);

function append_heatmap(div_id, data, color, min, max) {
    var width = 960, height = 780, 
        cell_size = 25, label_size = 100;
    
    var longest = data.source_structures.reduce(function (a, b) { return a.length > b.length ? a : b; });

    var svg = d3.select(div_id).append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g");

    var meta_container = $("<div style='padding-top: 30px;'>").attr("class","meta col-md-4").appendTo($(div_id + "_parent"));
    // Build the D3 components that display the heatmap color legend.
    function build_legend(chart_width, chart_height) {
        chart_width = Math.max(Math.min(chart_width, 500), 100)
        // Make an array of values, one for each pixel in the width of the legend.
        var legend_data = [];
        for (var i = 0; i < chart_width; i++) { legend_data.push(i / chart_width * 1); }

        // This scale handles interpolation between projection volume values and 
        // legend position.
        var legend_scale = d3.scale.linear()
            .domain([min,max])
            .range([0,chart_width]);
        // This object will generate the tick values along the bottom of the legend.
        var legend_axis = d3.svg.axis()
            .scale(legend_scale)
            .orient("bottom")
            .tickValues(color.domain());

        // Append the group that will hold all of the legend components.  A set of single-pixel
        // rectangles are drawn across the legend and colored by their interpolated color value.
        svg.append("g")
           .attr("class", "legend axis")
           .attr("transform", "translate(0,-100)")
           .call(legend_axis)
           .selectAll(".legend_cell")
           .data(legend_data)
           .enter().append("rect")
           .attr("x", function(d,i) { return i; })
           .attr("y", -cell_size)
           .attr("width", 1)
           .attr("height", cell_size)
           .attr("fill", function(d) { return color(d); });

        // A title for the legend.
        svg.append("text")
           .attr("x", chart_width / 2)
           .attr("y", -65)
           .attr("text-anchor", "middle")
           .text("normalized expression value");
    }

    // Construct the heatmap and its axes. The data supplied to this method
    // is an array of source-target volume values.  
    function build_heatmap(data, chart_width, chart_height) {

        // This group will hold all of the rectangles within the heatmap.
        var cell_group = svg.append("g");

        // Make a rectangle for each source-target projection volume value.
        var rects = cell_group.selectAll(".cell")
            .data(data.both_data)
            .enter().append("rect")
            .attr("x", function(d) { return d.source_index * cell_size; })
            .attr("y", function(d) { return d.target_index * cell_size; })
            .style("fill", function(d) { return color(d.value); })
            .attr("width", cell_size)
            .attr("height", cell_size)
            .on("mouseover", function(d) {
                var sample_name = data.source_structures[d.source_index];
                $.get("/session/" + sample_name, function(metadata) {
                    metadata = JSON.parse(metadata);
                    var metadata_html = ""
                    for (var key in metadata) {
                        metadata_html += "<strong>" + key + "</strong>: " + metadata[key] + "<br />";
                    }
                    var build_html = "<p class='font-weight-bold font-italic'>" + sample_name + "<br />" +
                        data.target_structures[d.target_index] + "</p>" +
                        "<p class='font-weight-normal'>" + "<strong>expression value:</strong> " +
                        Math.ceil(d.value * 1000.0) / 1000.0 +
                        "<br />" + "<strong>odds ratio:</strong> " +
                        Math.ceil(data.oddsratios[d.target_index] * 1000.0) / 1000.0 + "</p>" +
                        "<p>" + metadata_html + "</p>";
                    meta_container.html(build_html);
                });
            });
        
        // Construct text labels for the y axis
        svg.append("g")
           .attr("class", "y axis")
           .selectAll("text")
           .data(data.target_structures)
           .enter().append("text")
           .attr("y", function(d,i) { return i * cell_size + 17.5; })
           .attr("x", -5)
           .attr("text-anchor", "end")
           .text(function(d) { return d; });

        // Construct text labels for the x axis
        svg.append("g")
           .attr("class", "x axis")
           .attr("transform", "translate(0,"+ chart_height +")")
           .selectAll("text")
           .data(data.source_structures)
           .enter().append("text")
           .attr("transform", function(d,i) { 
                var x = (i * cell_size);
                var y = 0;
                return "translate("+ (x + 8) + "," + (y + 5) + ") rotate(90)" ; 
           })
           .text(function(d) { return d; })
           .style('fill', function(d) {
                if (data.whitelist.hasOwnProperty("most") 
                    && $.inArray(d, data.whitelist.most) > -1) {
                    return 'red';
                }
                if (data.whitelist.hasOwnProperty("least")
                    && $.inArray(d, data.whitelist.least) > -1) {
                    return 'blue';
                }
                return 'black';
           });

        // A title for the x axis.
        svg.append("text")
           .attr("x", 50)
           .attr("y", -20)
           .attr("text-anchor", "middle")
           .text("Samples");

        // A title for the y axis.
        svg.append("text")
           .attr("text-anchor", "middle")
           .attr("transform","translate(-110," + (chart_height / 2) +") rotate(90)")
           .text("Genes");
    }
    var chart_height = cell_size * data.target_structures.length;
    var chart_width = cell_size * data.source_structures.length;
    build_heatmap(data, chart_width, chart_height);
    build_legend(chart_width, chart_height);
    bounding = svg.node().getBBox();
    svg.attr("transform", "translate(" +
             bounding.x * -1 + "," +
             bounding.y * -1 + ")"
            );
    d3.select("svg").attr("width", bounding.width);
    d3.select("svg").attr("height", bounding.height);
}

append_heatmap("#heatmap", data, colorbar, 0.0, 1.0);

</script>
</html>
