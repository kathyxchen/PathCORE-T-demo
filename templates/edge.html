{% extends "layout.html" %}
{% block title %}Edge{% endblock %}
{% block head %}
  {{ super() }}
  <style>
  .pw1 {
   color: pink;
  }

  .pw2 {
   color: green;
  }

  .both {
    color: purple;
  }
  </style>
  <script src="{{ url_for('static', filename='js/pathcore-heatmap.js') }}">
  </script>
{% endblock %}
{% block content %}
<div id="overview" class="container">
    <div class="row">
        <h3>
          <span class="pw1">{{pw1}}</span> 
          <span class="pw2">{{pw2}}</span>
        </h3>
        <h4>
          <a href="{{ url_for('pathcore_network') }}">PathCORE network</a>
        </h4>
        <h4 class="description"><b>Description</b></h4>
        <p>
            For every gene annotated to one or both of {{pw1}} and {{pw2}},
            we computed an odds ratio that measures how often we observe a
            feature enriched for both the gene and the edge of interest.
            This page displays a maximum of 20 genes that had an odds
            ratio of above 1. 
            We do this to highlight the genes that are most observed
            with the current pathway co-occurrence relationship.
        </p>
        <p>        
            A summary expression score per sample was determined based on
            the normalized expression values of the selected genes,
            where each expression value was weighted by the corresponding
            gene's odds ratio.
            Displayed are the <a href="#most-expressed-samples">
              20 most expressed</a>
            and <a href="#least-expressed-samples">
              20 least expressed</a> samples. 
        </p>
        <p>
            If a gene-by-sample square has an experiment associated with
            it (the information shows up when you hover over the square),
            you can <b>click through</b> to view an <b>experiment page</b>
            that displays the selected genes' expression values for
            all samples from that experiment.
        </p>
        <p>
            When available, we provide the common name for a given PA
            gene locus tag. Genes in <span class="pw1">pink</span> are
            annotated to <span class="pw1">{{pw1}}</span> in KEGG,
            <span class="pw2">green</span> to <span class="pw2">{{pw2}}</span>,
            and <span class="both">purple</span> to
            <span class="both">both</span>.
        </p>
        <h4>
          <a href="{{ url_for('edge_excel_file', edge_pws=pw1 + '&' + pw2) }}">
            Click here to download a .csv file of the data provided in the
            two heatmaps.
          </a>
        </h4>
    </div>
</div>
<div class="container" id="most-expressed-samples">
<h4>20 most expressed samples</h4>
<div class="row">
    <div class="col-xs-6">
    <div class="text-right">
      <button type="button" class="btn btn-default toggle-genes">
        Sort genes alphabetically
      </button>
    </div>
    </div>
</div>
<div class="row" id="most_expressed_parent">
    <div class="col-md-4 sample-view" id="most_expressed">
    </div>
</div>
</div>
<div class="container" id="least-expressed-samples">
<h4>20 least expressed samples</h4>
<div class="row">
    <div class="col-xs-6">
    <div class="text-right">
        <button type="button" class="btn btn-default toggle-genes">
          Sort genes alphabetically
        </button>
    </div>
    </div>
</div>
<div class="row" id="least_expressed_parent">
    <div class="col-md-4 sample-view" id="least_expressed">
    </div>
</div>
</div>

<script type="text/javascript">
const edgeInfo = JSON.parse(JSON.stringify({{ edge_info|safe }}));

const mostExpressedData = 
    {"samplesX": edgeInfo["most_expressed_samples"],
     "genesY": edgeInfo["gene_names"],
     "heatmapData": edgeInfo["most_expressed_heatmap"],
     "meta": edgeInfo["most_metadata"],
     "oddsratios": edgeInfo["odds_ratios"],
     "ownership": edgeInfo["ownership"]
    };
const leastExpressedData =
    {"samplesX": edgeInfo["least_expressed_samples"],
     "genesY": edgeInfo["gene_names"],
     "heatmapData": edgeInfo["least_expressed_heatmap"],
     "meta": edgeInfo["least_metadata"],
     "oddsratios": edgeInfo["odds_ratios"],
     "ownership": edgeInfo["ownership"]
    };

const mostExprMinMax = expressionMinMax(mostExpressedData["heatmapData"]);
const leastExprMinMax = expressionMinMax(leastExpressedData["heatmapData"]);

const mostExprColors = ["white", "yellow", "red", "black"];
const leastExprColors = ["white", "blue", "purple", "black"];

const mostExprColorbar = colorbar(
  mostExprMinMax["min"], mostExprMinMax["max"], mostExprColors); 
const leastExprColorbar = colorbar(
  leastExprMinMax["min"], leastExprMinMax["max"], leastExprColors);

const copyMost = replaceWithAlphabetical(
  jQuery.extend(true, {}, mostExpressedData));
const copyLeast = replaceWithAlphabetical(
  jQuery.extend(true, {}, leastExpressedData));

const mostExprHeatmap = createHeatmap("#most_expressed",
  mostExpressedData, mostExprColorbar,
  mostExprMinMax["min"], mostExprMinMax["max"]);
const leastExprHeatmap = createHeatmap("#least_expressed",
  leastExpressedData, leastExprColorbar,
  leastExprMinMax["min"], leastExprMinMax["max"]);

mostExprHeatmap.prependTo($("#most_expressed_parent"));
leastExprHeatmap.prependTo($("#least_expressed_parent"));

function expressionMinMax(data) {
    const minExpression = Math.min.apply(
      Math, data.map(function(d) { return d.value; }));
    const maxExpression = Math.max.apply(
      Math, data.map(function(d) { return d.value; }));
    return {"min": minExpression, "max": maxExpression};
}

function colorbar(minExpression, maxExpression, colors) {
    const difference = maxExpression - minExpression;
    const domain = [
      minExpression,
      minExpression + difference / 3.0,
      maxExpression - difference / 3.0,
      maxExpression];
    return d3.scale.linear().domain(domain).range(colors);
}

function indexSort(arr) {
    for (let i = 0; i < arr.length; i++) {
      arr[i] = [arr[i], i];
    }
    arr.sort(function(left, right) {
      return left[0] < right[0] ? -1 : 1;
    });
    arr.indicesSorted = [];
    for (let j = 0; j < arr.length; j++) {
      arr.indicesSorted.push(arr[j][1]);
      arr[j] = arr[j][0];
    }
    return arr;
}

function rearrangeByIndices(arr, indexArr) {
    let rearrangedArr = Array(arr.length);
    for (let i = 0; i < arr.length; i++) {
      rearrangedArr[i] = arr[indexArr[i]];
    }
    return rearrangedArr;
}

function rearrangeHeatmapIndices(heatmapData, indexArr) {
    let rearrangedHeatmapData = [];
    let heatmapCells = {};
    
    for (let i = 0; i < heatmapData.length; i++) {
      let cell = heatmapData[i];
      let key = cell.source_index + " " + cell.target_index;
      heatmapCells[key] = cell.value;
    }

    for (let i = 0; i < heatmapData.length; i++) {
      let heatmapCell = {};
      let currentGenePos = heatmapData[i]["target_index"];

      heatmapCell["source_index"] = heatmapData[i]["source_index"];
      heatmapCell["target_index"] = heatmapData[i]["target_index"];
      heatmapCell["value"] = heatmapCells[heatmapCell.source_index + " " +
                                          indexArr[currentGenePos]];
      rearrangedHeatmapData.push(heatmapCell);
    }

    return rearrangedHeatmapData;
}

function replaceWithAlphabetical(copyData) {
    alphabeticalGenes = indexSort(copyData["genesY"]);
    copyData = {
        "samplesX": copyData["samplesX"],
        "genesY": alphabeticalGenes,
        "heatmapData": rearrangeHeatmapIndices(
          copyData["heatmapData"], alphabeticalGenes.indicesSorted),
        "meta": copyData["meta"],
        "oddsratios": rearrangeByIndices(
          copyData["oddsratios"], alphabeticalGenes.indicesSorted),
        "ownership": rearrangeByIndices(
          copyData["ownership"], alphabeticalGenes.indicesSorted)
    };
    return copyData;
}
</script>
{% endblock %}
